

```plantuml
@startmindmap
* 单向函数
**_ f(x) = y 
***_:已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x);
而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。;

**_ f(x;h) = y 
***_ 一个较弱的单向函数。
***_:
已知单向陷门函数 f，陷门 h，
给定任意一个输入 x，易计算出输出 y=f(x;h)；
而给定一个输出 y，
假设存在 f(x;h)=y，很难根据 f 来计算出 x，
但可以根据 f 和 h 来推导出 x。;

@endmindmap
```


```plantuml
@startmindmap
* 加密算法
**_ 对称加密算法
***_ 加解密同一密匙
**_ 非对称加密算法
***_ 公匙加密，私钥解密
@endmindmap
```


```plantuml
@startmindmap
* SSL/TLS
**_:安全套接字协议(Secure Sockets Layer)
TLS与SSL在传输层与应用层之间对网络连接进行加密。;
**_ https://baike.baidu.com/item/ssl/320778


**_ 工作流程
***_ 握手阶段
****_ 采用非对称加密方式，来传后续数据传输的所需要的密匙。
***_ 数据传输阶段
****_ 采用对称加密方式。

@endmindmap
```




```plantuml
@startuml

autonumber

Control Cilent as C
Control Server as S

title 单向认证 
C -> S : 发送客户端SSL版本信息
|||
C <- S : 服务端给客户端返回SSL版本、随机数等信息、以及服务器公钥
|||
C -> C : 客户端校验服务端证书是否合法，合法继续，否则警告
|||
C -> S : 客户端发送自己可支持的对称加密方案给服务端，供其选择
||| 
S -> S : 服务端选择加密程度较高的加密方式
|||
S -> C : 将选择好的加密方案以明文的方式发送给客户端
|||
C -> S : 客户端收到加密方式之后，产生随机码，作为对称加密密钥，\n使用服务端公钥进行加密后，发送给服务端
|||

S -> C : 服务端使用私钥对加密的信息进行解密，获得对称加密的密钥
|||

C -> S : 
S -> C : 对称加密，确保通信安全


@enduml
```

```plantuml
@startuml

autonumber

Control Cilent as C
Control Server as S

title 双向认证 
C -> S : 发送客户端SSL版本信息
|||
C <- S : 服务端给客户端返回SSL版本、随机数等信息、以及服务器公钥
|||
C -> C : 客户端校验服务端证书是否合法，合法继续，否则警告
|||
C -> S : 客户端验证通过后，将自己的证书及公钥发送至服务端
||| 
S -> S : 对客户端证书进行校验，校验结束后获得客户端公钥
||| 
C -> S : 客户发送自己可支持的对称加密方式给服务端，供其选择
|||
S -> S : 服务端选择加密程度较高的加密方式
|||
S -> C : 将选择好的加密方案使用客户端的公钥进行加密后发送给客户端
|||
C -> S : 客户端收到加密方式之后，产生随机码，作为对称加密密钥，\n使用服务端公钥进行加密后，发送给服务端
|||

S -> C : 服务端使用私钥对加密的信息进行解密，获得对称加密的密钥
|||

C -> S : 
S -> C : 对称加密，确保通信安全


@enduml
```

#### 总结

1. 客户端提供ssl版本，获得证书公钥
2. 校验证书
3. 协商对称加密方式
4. 使用非对称算法，获得对称加密的密钥

#### 参考
- https://baike.baidu.com/item/%E5%8D%95%E5%90%91%E9%99%B7%E9%97%A8%E5%87%BD%E6%95%B0/3869579
- 《图解HTTP》
- https://blog.csdn.net/duanbokan/article/details/50847612
